Міністерство освіти і науки України 
Харківський національний університет радіоелектроніки 
Кафедра програмної інженерії 














Звіт з лабораторної роботи № 4
 з дисципліни «Аналіз та рефакторинг коду»










Перевірив                                                            Виконав 
ст. викладач ПІ                                                          ст. групи ПЗПІ-22-7 
Сокорчук Ігор Петрович                                     Кравцов Я.П.






























Харків 2024


1 Вступ 


Створити IoT-клієнт для збору, обробки та передачі даних на сервер відповідно до принципів Інтернету речей. Реалізувати ефективну бізнес-логіку, функціонал налаштування пристрою та забезпечити плавну інтеграцію з іншими компонентами системи.




2 ХІД РОБОТИ


2.1 Опис процесу створення симулятора доступу
Цей код моделює систему контролю доступу з використанням ідентифікаційних карток (RFID/NFC) і дверей. Він дозволяє симулювати процес перевірки доступу користувача до певної двері через консольне застосування на Node.js.
Ключовою метою є забезпечення інтерактивного інтерфейсу для симуляції:
Отримання даних про карти та двері із сервера.
Вибір карти та двері через консоль.
Відправка запиту на сервер для перевірки доступу.
Відображення результатів у реальному часі з використанням анімації завантаження.


2.2 Загальна логіка роботи
1. Ініціалізація програми:
   * Підключаються необхідні бібліотеки (axios, readline).
   * Визначається URL для API (SERVER_URL).
2. Отримання даних:
   * Виконується запит до сервера для отримання списку карток та дверей.
3. Інтерактивний інтерфейс:
   * Користувач вводить ID картки.
   * Програма перевіряє, чи існує така картка.
   * Користувач вводить ID двері.
   * Програма перевіряє, чи існує така двері.
4. Перевірка доступу:
   * Відправляється HTTP-запит до сервера для перевірки доступу.
   * Відображаються результати: доступ дозволено чи заборонено.
5. Цикл вводу:
   * Після завершення операції програма повертається до очікування нового вводу.


2.3 Детальний огляд коду
Ініціалізація та підключення бібліотек


1. const readline = require('readline');
2. const axios = require('axios'); 
3. const SERVER_URL = 'http://localhost:5000'; 


* readline: для отримання вводу від користувача через консоль.
* axios: для HTTP-запитів до API.
* SERVER_URL: базова адреса сервера.
Змінні для збереження даних




1. let cards = [];
2. let doors = [];


* cards: масив для збереження даних про картки, отриманих з сервера.
* doors: масив для збереження даних про двері.


Інтерфейс користувача


1. const rl = readline.createInterface({
2.     input: process.stdin,
3.     output: process.stdout
4. });


readline.createInterface: створює інтерфейс для взаємодії з користувачем через консоль


Функція для показу анімації завантаження


1. function showLoading(message = 'Processing') {
2.     const loadingChars = ['|', '/', '-', '\\'];
3.     let i = 0;
4.     return setInterval(() => {
5.         process.stdout.write(`\r${message} ${loadingChars[i++ % loadingChars.length]}`);
6.     }, 300);
7. }


* Виводить анімацію завантаження у консоль.
* Використовується під час запитів до сервера.


Отримання списку карток


1. const fetchCards = async () => {
2.     try {
3.         console.log('🔄 Fetching available cards from the server...');
4.         const response = await axios.get(`${SERVER_URL}/user`);
5.         cards = response.data;
6.         console.log('✅ Cards loaded successfully!');
7.         console.table(cards);
8.     } catch (error) {
9.         console.error('❌ Error fetching cards:', error.message);
10.     }
11. }


* Виконує HTTP GET-запит до сервера (/user) для отримання списку карток.
* Зберігає отримані дані у змінну cards.
* Виводить таблицю з картками у консоль.
Отримання списку дверей


1. async function fetchDoors() {
2.     try {
3.         console.log('🔄 Fetching available doors from the server...');
4.         const response = await axios.get(`${SERVER_URL}/door`);
5.         doors = response.data;
6.         console.log('✅ Doors loaded successfully!');
7.         console.table(doors);
8.     } catch (error) {
9.         console.error('❌ Error fetching doors:', error.message);
10.     }
11. }




* Виконує HTTP GET-запит до сервера (/door) для отримання списку дверей.
* Зберігає отримані дані у змінну doors.
* Виводить таблицю з дверима у консоль.
Перевірка доступу
1. async function checkAccess(userId, doorId) {
2.     let loader = showLoading('🔄 Verifying access');
3.     try {
4.         console.log(userId, doorId)
5.         const response = await axios.post(`${SERVER_URL}/door/verify-user`, {
6.             userId, doorId
7.         });
8.         
9.         clearInterval(loader);
10.         console.log('\n✅ Access Granted!');
11.         console.log(`Card: ${userId} → Door: ${doorId}`);
12.     } catch (error) {
13.         clearInterval(loader);
14.         if (error.response) {
15.             console.error('\n❌ Access Denied:', error.response.data.message);
16.         }
17.     }
18. }


* Виконує HTTP POST-запит до /door/verify-user з параметрами userId та doorId.
* Виводить результат перевірки доступу.
Головний цикл програми


1. async function main() {
2.     console.log('🚀 Welcome to the Access Control Simulator');
3.     console.log('--------------------------------------------');
4.     await fetchCards()
5.     await fetchDoors();
6.     
7.     function askForInput() {
8.         rl.question('\n🔑 Enter Card ID (or type "exit" to quit): ', (cardId) => {
9.             if (cardId.toLowerCase() === 'exit') {
10.                 console.log('👋 Exiting...');
11.                 rl.close();
12.                 return;
13.             }
14. 15.             const card = cards.find(c => c.id === Number(cardId));
16.             if (!card) {
17.                 console.log('❌ Invalid Card ID. Please try again.');
18.                 askForInput();
19.                 return;
20.             }
21. 22.             console.log(`🪪 Card selected: ${card.username} (${card.id})`);
23. 24.             rl.question('🚪 Enter Door ID: ', async (doorId) => {
25.                 const door = doors.find(d => d.id === Number(doorId));
26. 27.                 if (!door) {
28.                     console.log('❌ Invalid Door ID. Please try again.');
29.                     askForInput();
30.                     return;
31.                 }
32. 33.                 console.log(`🚪 Door selected: ${door.buildingId} (${door.id})`);
34. 35.                 await checkAccess(card.id, doorId);
36.                 askForInput(); 
37.             });
38.         });
39.     }
40. 41.     askForInput();
42. }
43. 44. main();


* Головний цикл забезпечує інтерактивний ввід даних користувачем.
* Викликає функції для перевірки карти та дверей.


2.4 UML Діаграма діяльності
Опис UML діаграми діяльності
UML діаграма діяльності показує послідовність дій, які відбуваються під час запиту на доступ до дверей з використанням ІоТ-клієнта.


Основні компоненти діаграми:
1. Актор (Користувач): Ініціює запит на доступ.
2. API контролер: Обробляє запит від користувача та передає його до сервісу доступу.
3. Сервіс доступу: Виконує перевірку доступу, взаємодіє з базою даних.
4. База даних: Зберігає інформацію про користувачів та їх права доступу.
5. Умова (Decision Node): Перевірка, чи користувач має доступ до конкретних дверей.
6. Результат: Підтвердження або відмова у доступі.
7. Послідовність процесу:
1. Запит користувача:
   * Користувач надсилає запит на доступ через API-контролер.
2. Обробка API контролером:
   * API контролер передає запит до сервісу доступу.
3. Перевірка доступу:
   * Сервіс доступу перевіряє дані користувача через базу даних.
4. Умова доступу:
   * Якщо користувач має доступ:
      * Сервіс повертає підтвердження доступу.
   * Якщо доступ заборонено:
      * Сервіс повертає помилку доступу.
5. Відповідь користувачу:
   * API контролер надсилає відповідь користувачу.


Детальний опис діаграми:
1. Початок процесу: Користувач надсилає запит до API-контролера.
2. API контролер: Обробляє запит та передає його до DoorService.
3. Сервіс доступу: Виконує перевірку даних користувача, взаємодіє з базою даних.
4. Умова (Рішення): Якщо користувач має доступ:
   * Доступ дозволено, і система повертає підтвердження.
   * Інакше, доступ заборонено, і система повертає помилку.
5. API контролер: Надсилає результат запиту користувачу.
Результат: Користувач отримує підтвердження або помилку доступу.


  

Риснок 1 - UML Діаграма діяльності


2.5 UML Діаграма взаємодії
UML діаграма взаємодії відображає, як об'єкти взаємодіють між собою під час процесу перевірки доступу користувача до дверей.
Основні компоненти діаграми:
1. Користувач: Ініціює запит.
2. API контролер: Приймає запит від користувача та передає далі.
3. Сервіс доступу: Перевіряє доступ та взаємодіє з базою даних.
4. База даних: Зберігає дані користувачів та їх права.
5. Рішення (Decision Node): Визначає результат перевірки доступу.
Послідовність процесу:
1. Користувач надсилає запит:
   * Запит на доступ до дверей через API.
2. API контролер передає запит:
   * Запит передається до DoorService.
3. Сервіс доступу перевіряє дані:
   * DoorService надсилає запит до бази даних.
4. База даних надає результат:
   * Повертає дані про доступ користувача.
5. Умова перевірки:
   * Якщо доступ дозволено → підтвердження доступу.
   * Якщо доступ заборонено → помилка доступу.
6. API контролер повертає відповідь:
   * Результат передається користувачу.


  

Риснок 2 - UML Діаграма взаємодії






Висновки 




У ході виконання лабораторної роботи було розроблено симулятор контролю доступу на основі IoT-клієнта, який забезпечує взаємодію з сервером через HTTP-запити. Реалізовано функції отримання даних про картки та двері, перевірки доступу користувачів і відображення результатів у реальному часі. Також було створено UML-діаграми діяльності та взаємодії, що наочно демонструють логіку та послідовність обробки запитів. Отримані результати можуть бути використані для подальшого розвитку системи та інтеграції з реальними IoT-пристроями.
Посилання на відеозапис: 
https://youtu.be/MDsnUZC-fpw